name: Notify Discord on change

on:
  - push
  - create
  - delete
  - fork
  - issue_comment
  - issues
  - label
  - pull_request

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (for jq availability)
        uses: actions/checkout@v4

      - name: Prepare variables
        shell: bash
        run: |
          set -euo pipefail
          EVENT_JSON="$GITHUB_EVENT_PATH"

          REPO_NAME="${GITHUB_REPOSITORY##*/}"
          BRANCH="${GITHUB_REF##refs/heads/}"  # Use GITHUB_REF to extract branch

          # Default values
          COMMIT_COUNT=0
          COMMITS_TEXT="No commits found for this event."
          LATEST_SHA=""
          TITLE=""
          DESCRIPTION=""
          BUTTON_URL=""
          # Author defaults
          AUTHOR="${GITHUB_ACTOR}"
          AUTHOR_USERNAME="${GITHUB_ACTOR}"
          AUTHOR_ICON="https://github.com/${AUTHOR_USERNAME}.png"

          EVENT_TYPE="${GITHUB_EVENT_NAME:-}"

          case "$EVENT_TYPE" in
            push|create|delete|fork)
              # Get commits array length (0 if not push)
              COMMIT_COUNT=$(jq '(.commits | length) // 0' "$EVENT_JSON")
              
              # Build commit list (hash + message)
              if [ "$COMMIT_COUNT" -gt 0 ]; then
                COMMITS_TEXT=$(jq -r '.commits[] | "\(.id[0:7]) \(.message)"' "$EVENT_JSON" | sed 's/"/\\"/g')
                LATEST_SHA=$(jq -r '.commits[-1].id' "$EVENT_JSON")
              else
                COMMITS_TEXT="No commits found for this event."
                LATEST_SHA=$(jq -r '.head_commit.id // .after // ""' "$EVENT_JSON")
              fi

              # Determine button URL (link to latest commit or repo)
              if [ -n "$LATEST_SHA" ] && [ "$LATEST_SHA" != "null" ]; then
                BUTTON_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/$LATEST_SHA"
              else
                BUTTON_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"
              fi

              # Author info (prefer commit author if available)
              COMMIT_AUTHOR_NAME="$(jq -r '.head_commit.author.name // ""' "$EVENT_JSON")"
              COMMIT_AUTHOR_USERNAME="$(jq -r '.head_commit.author.username // ""' "$EVENT_JSON")"
              if [ -n "$COMMIT_AUTHOR_NAME" ]; then
                AUTHOR="$COMMIT_AUTHOR_NAME"
              else
                AUTHOR="${GITHUB_ACTOR}"
              fi
              if [ -n "$COMMIT_AUTHOR_USERNAME" ]; then
                AUTHOR_USERNAME="$COMMIT_AUTHOR_USERNAME"
              else
                AUTHOR_USERNAME="${GITHUB_ACTOR}"
              fi
              AUTHOR_ICON="https://github.com/$AUTHOR_USERNAME.png"

              # Compose title/description for commits
              commit_label="${COMMIT_COUNT} new commit"
              if [ "$COMMIT_COUNT" -ne 1 ]; then
                commit_label="${commit_label}s"
              fi
              TITLE="[${REPO_NAME}:${BRANCH}] ${commit_label}"
              DESCRIPTION="$COMMITS_TEXT"
              ;;

            issues|issue_comment)
              # Issue related events
              ISSUE_ACTION=$(jq -r '.action // ""' "$EVENT_JSON")
              ISSUE_NUMBER=$(jq -r '.issue.number // empty' "$EVENT_JSON")
              ISSUE_TITLE=$(jq -r '.issue.title // ""' "$EVENT_JSON")
              ISSUE_BODY=$(jq -r '.issue.body // ""' "$EVENT_JSON")
              ISSUE_URL=$(jq -r '.issue.html_url // ""' "$EVENT_JSON")

              # If it's an issue_comment event, prefer comment excerpt
              if [ "$EVENT_TYPE" = "issue_comment" ]; then
                COMMENT_BODY=$(jq -r '.comment.body // ""' "$EVENT_JSON")
                COMMENT_URL=$(jq -r '.comment.html_url // ""' "$EVENT_JSON")
                if [ -n "$COMMENT_BODY" ]; then
                  DESCRIPTION="$COMMENT_BODY"
                  BUTTON_URL="${COMMENT_URL:-$ISSUE_URL}"
                  TITLE="[${REPO_NAME}] Issue comment ${ISSUE_ACTION}: #${ISSUE_NUMBER} ${ISSUE_TITLE}"
                else
                  DESCRIPTION="$ISSUE_BODY"
                  BUTTON_URL="$ISSUE_URL"
                  TITLE="[${REPO_NAME}] Issue ${ISSUE_ACTION}: #${ISSUE_NUMBER} ${ISSUE_TITLE}"
                fi
              else
                DESCRIPTION="$ISSUE_BODY"
                BUTTON_URL="$ISSUE_URL"
                TITLE="[${REPO_NAME}] Issue ${ISSUE_ACTION}: #${ISSUE_NUMBER} ${ISSUE_TITLE}"
              fi

              # Author: use actor for issue/comment events
              AUTHOR="${GITHUB_ACTOR}"
              AUTHOR_ICON="https://github.com/${GITHUB_ACTOR}.png"
              ;;

            pull_request)
              PR_ACTION=$(jq -r '.action // ""' "$EVENT_JSON")
              PR_NUMBER=$(jq -r '.pull_request.number // empty' "$EVENT_JSON")
              PR_TITLE=$(jq -r '.pull_request.title // ""' "$EVENT_JSON")
              PR_BODY=$(jq -r '.pull_request.body // ""' "$EVENT_JSON")
              PR_URL=$(jq -r '.pull_request.html_url // ""' "$EVENT_JSON")

              TITLE="[${REPO_NAME}] PR ${PR_ACTION}: #${PR_NUMBER} ${PR_TITLE}"
              DESCRIPTION="$PR_BODY"
              BUTTON_URL="$PR_URL"

              # Author: PR user (fallback to actor)
              PR_USER_LOGIN=$(jq -r '.pull_request.user.login // empty' "$EVENT_JSON")
              if [ -n "$PR_USER_LOGIN" ]; then
                AUTHOR="$PR_USER_LOGIN"
                AUTHOR_ICON="https://github.com/${PR_USER_LOGIN}.png"
              else
                AUTHOR="${GITHUB_ACTOR}"
                AUTHOR_ICON="https://github.com/${GITHUB_ACTOR}.png"
              fi
              ;;

            *)
              # Fallback for unhandled event types
              TITLE="[${REPO_NAME}] ${EVENT_TYPE} event"
              DESCRIPTION="Event type ${EVENT_TYPE} occurred. See repository for details."
              BUTTON_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"
              AUTHOR="${GITHUB_ACTOR}"
              AUTHOR_ICON="https://github.com/${GITHUB_ACTOR}.png"
              ;;
          esac

          # Export variables for later steps
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "COMMIT_COUNT=$COMMIT_COUNT" >> $GITHUB_ENV
          echo "COMMITS_TEXT<<EOF" >> $GITHUB_ENV
          echo "$COMMITS_TEXT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "BUTTON_URL=$BUTTON_URL" >> $GITHUB_ENV
          echo "AUTHOR=$AUTHOR" >> $GITHUB_ENV
          echo "AUTHOR_ICON=$AUTHOR_ICON" >> $GITHUB_ENV

          # Also export TITLE and DESCRIPTION for the payload builder (DESCRIPTION as multiline)
          echo "TITLE=$TITLE" >> $GITHUB_ENV
          echo "DESCRIPTION<<EOF" >> $GITHUB_ENV
          echo "$DESCRIPTION" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Build payload with all commits
        run: |
          python3 - <<'PY' > payload.json
          import json, os, re

          # Prefer explicit TITLE/DESCRIPTION from the prepare step (issues/PRs/etc.)
          title_env = os.getenv("TITLE")
          description_env = os.getenv("DESCRIPTION")
          commit_count = int(os.getenv("COMMIT_COUNT", "0"))
          repo_name = os.getenv("REPO_NAME", "")
          branch = os.getenv("BRANCH", "")
          commits_text = os.getenv("COMMITS_TEXT", "No commits found.")
          commit_url = os.getenv("BUTTON_URL", "")

          # If TITLE/DESCRIPTION were provided (issue/pr/event), use them directly
          if title_env:
              title = title_env
              description = description_env or ""
              url = commit_url or ""
          else:
              # Fallback to commit-style payload generation
              commit_label = f"{commit_count} new commit" + ("" if commit_count == 1 else "s")
              def hyperlink_hashes(text, url):
                  lines = text.splitlines()
                  new_lines = []
                  for line in lines:
                      match = re.match(r'^([0-9a-f]{7,40})( .*)?$', line)
                      if match and url:
                          hash_part = match.group(1)
                          rest = match.group(2) or ""
                          new_lines.append(f"[{hash_part}]({url}) **|** {rest}")
                      else:
                          new_lines.append(line)
                  return "\n".join(new_lines)
              description = hyperlink_hashes(commits_text, commit_url)
              title = f"[{repo_name}:{branch}] {commit_label}"
              url = commit_url or ""

          payload = {
              "embeds": [
                  {
                      "author": {
                          "name": os.getenv("AUTHOR", ""),
                          "icon_url": os.getenv("AUTHOR_ICON", "")
                      },
                      "title": title,
                      "url": url,
                      "description": description,
                      "color": 8022983
                  }
              ]
          }

          print(json.dumps(payload))
          PY

      - name: Send to Discord webhook
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
        env:
          WEBHOOK1: ${{ secrets.DISCORD_WEBHOOK_URL }}
          WEBHOOK2: ${{ secrets.DISCORD_WEBHOOK_URL2 }}
        run: |
          set -euo pipefail

          # iterate over each webhook env var (works even if one is empty)
          for WEBHOOK in "$WEBHOOK1" "$WEBHOOK2"; do
            if [ -z "$WEBHOOK" ]; then
              echo "Missing webhook URL, skipping..."
              continue
            fi

            tmpfile=$(mktemp)
            http_status=$(curl -sS -X POST \
              -H "Content-Type: application/json" \
              --data-binary @payload.json \
              "$WEBHOOK" -w "%{http_code}" -o "$tmpfile") || true

            echo "Discord response (body):"
            if [ -s "$tmpfile" ]; then
              cat "$tmpfile" || true
            else
              echo "(no body)"
            fi

            echo "HTTP status: $http_status"
            rm -f "$tmpfile"

            if [ "$http_status" -ge 400 ]; then
              echo "Webhook returned HTTP $http_status — failing job." >&2
              exit 1
            fi
          done